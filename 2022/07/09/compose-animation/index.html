<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>oMMiao&#39;s Blog</title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">oMMiao&#39;s Blog</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            Compose Animation实践
        </div>
        <div class="post-meta">
            2022-07-09
        </div>
    

    <div class="post-md">
        <p>作为移动端App来说，动画效果是页面切换和用户交互过程中不可缺少的一部分，优雅炫酷的动画可以提升App整体的质量，给用户带来赏心悦目的使用体验。<a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose">Jetpack Compose</a>作为Google官方最新推出的UI开发框架，可以极大地提高UI开发效率，对动画的支持也十分友好，此篇文章，我按照常见的动画场景作为分类，记录一下各种场景如何在Compose中实现。</p>
<h3 id="场景一、View或Layout的外观属性变化"><a href="#场景一、View或Layout的外观属性变化" class="headerlink" title="场景一、View或Layout的外观属性变化"></a>场景一、View或Layout的外观属性变化</h3><blockquote>
<p>该场景是指此View或Layout在View树中一直存在，仅仅是Size&#x2F;Alpha&#x2F;Scale&#x2F;Offset&#x2F;Color等基本属性发生了变化。在这种场景下我们使用animate*AsState家族来实现动画效果。</p>
</blockquote>
<h4 id="适用于属性动画的animate-AsState家族"><a href="#适用于属性动画的animate-AsState家族" class="headerlink" title="适用于属性动画的animate*AsState家族"></a>适用于属性动画的animate*AsState家族</h4><p>之所以称之为家族，是因为这种命名方式的API有多个，涵盖了View的各个属性，此类API可以提供各种属性的state，state的刷新则由Compose内部实现，从而驱动UI按照state的变化而变化。</p>
<p>家族成员如下：</p>
<ul>
<li>animateIntAsState&#x2F;animateFloatAsState</li>
<li>animateDpAsState</li>
<li>animateColorAsState</li>
<li>animateSizeAsState&#x2F;animateIntSizeState</li>
<li>animateOffsetAsState&#x2F;animateIntOffsetState</li>
<li>animateRectAsState&#x2F;animateIntRectAsState</li>
<li>animateValueAsState</li>
</ul>
<p>其中<code>animateIntAsState/animateFloatAsState</code> API提供简单数据类型的<code>state</code>，可以根据需要灵活地用于各种属性动画；其他API则是针对性地提供对应类型属性的<code>state</code>，可以更加方便地绑定给View的<code>Modifier</code>；<code>animateValueAsState</code>则是范型类型的方法，用于扩展任意类型属性，同时也是其他所有API底层实现所调用的API，一般不需要直接使用<code>animateValueAsState</code>。</p>
<p>下面通过几个示例了解一下：</p>
<h5 id="1-示例一、animateDpAsState"><a href="#1-示例一、animateDpAsState" class="headerlink" title="1. 示例一、animateDpAsState"></a>1. 示例一、animateDpAsState</h5><p>此处假设我们需要Box在左右方向的Offset动画，代码如下：</p>
<pre><code class="kotlin">var state by remember &#123;
 mutableStateOf(State.START)
&#125;
val animateXOffset by animateDpAsState(
 targetValue = if (state == State.START) 0.dp else 100.dp
)
Box(modifier = Modifier.offset(x = animateXOffset))
</code></pre>
<p>代码十分简单，只需要将左右两个最终状态的Offset值设置到<code>targetValue</code>，然后将<code>animateDpAsState</code>返回的<code>state</code>绑定到<code>Modifier</code>就大工告成了！</p>
<p>接下来只需要改变目标状态，就可以看到下面的动画效果了：<br><img src="/compose-animation/demo.gif" alt="Demo"></p>

    </div>

</div>
                <div class="footer">
    <span>Copyright © 2022 oMMiao&#39;s Blog</span>
    <span>Powered By Hexo & ZheLi</span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>